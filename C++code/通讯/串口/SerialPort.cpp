#include "stdafx.h"
#include "SerialPort.h"


const unsigned char m_auchCRCHi[] =
{
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
};

const unsigned char m_auchCRCLo[] =
{
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
	0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
	0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
	0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
	0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
	0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
	0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
	0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
	0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
	0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
	0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
	0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
	0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
	0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
	0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
	0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

SerialPort::SerialPort()
{
}


SerialPort::~SerialPort()
{
}

unsigned short SerialPort::CalcCrcFast(unsigned char*puchMsg, unsigned short usDataLen)
{
	unsigned char uchCRCHi = 0xFF;
	unsigned char uchCRCLo = 0xFF;
	unsigned short uIndex;

	while (usDataLen--)
	{
		uIndex = uchCRCHi^*puchMsg++;
		uchCRCHi = uchCRCLo^m_auchCRCHi[uIndex];
		uchCRCLo = m_auchCRCLo[uIndex];
	}
	return(uchCRCHi << 8 | uchCRCLo);
}

bool SerialPort::openComm(CString CommPort)
{
	//设置事件 
	memset(&m_overlappedRead, 0, sizeof(OVERLAPPED));
	m_overlappedRead.hEvent = CreateEvent(NULL, FALSE, TRUE, L"portread");
	ASSERT(m_overlappedRead.hEvent != INVALID_HANDLE_VALUE);

	memset(&m_overlappedWrite, 0, sizeof(OVERLAPPED));
	m_overlappedWrite.hEvent = CreateEvent(NULL, FALSE, TRUE, L"portwrite");
	ASSERT(m_overlappedWrite.hEvent != INVALID_HANDLE_VALUE);

	CString commName(CommPort);

	//打开串口
	m_hComm = CreateFile(commName, GENERIC_READ | GENERIC_WRITE,
		0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE == m_hComm)
	{
		CloseHandle(m_hComm);
		return false;
	}

	//设置缓冲区大小
	SetupComm(m_hComm, 1024, 1024);

	//通讯参数
	DCB dcb;
	dcb.DCBlength = sizeof(DCB);
	GetCommState(m_hComm, &dcb);
	dcb.BaudRate = CBR_9600;//波特率
	dcb.ByteSize = 8;//数据位
	dcb.Parity = NOPARITY;//无校验
	dcb.StopBits = ONESTOPBIT;//1停止位
	SetCommState(m_hComm, &dcb);

	//设置超时
	COMMTIMEOUTS Timeouts;
	Timeouts.ReadIntervalTimeout = 50;
	Timeouts.ReadTotalTimeoutConstant = 500;
	Timeouts.ReadTotalTimeoutMultiplier = 50;
	Timeouts.WriteTotalTimeoutConstant = 500;
	Timeouts.WriteTotalTimeoutMultiplier = 50;
	SetCommTimeouts(m_hComm, &Timeouts);

	//清除缓冲区
	PurgeComm(m_hComm, PURGE_TXCLEAR | PURGE_RXCLEAR | PURGE_RXABORT | PURGE_TXABORT);

	//设置事件
	SetCommMask(m_hComm, EV_RXCHAR);

	return true;
}


unsigned long  SerialPort::WriteChar(unsigned long dwBufferLength, char *buff)
{
	DWORD dwError;
	if (ClearCommError(m_hComm, &dwError, NULL) && dwError > 0)	//清除错误
	{
		PurgeComm(m_hComm, PURGE_TXABORT | PURGE_TXCLEAR);
	}

	unsigned long uWriteLength = 0;
	if (!WriteFile(m_hComm, buff, dwBufferLength, &uWriteLength, &m_overlappedWrite))
	{
		if (GetLastError() == ERROR_IO_PENDING)
		{
			DWORD m_tmp = 0;
			m_tmp = WaitForSingleObject(m_overlappedWrite.hEvent, 1000);
			if (m_tmp == WAIT_TIMEOUT || m_tmp == WAIT_ABANDONED)
			{
				return(0);
			}
			else if (m_tmp == WAIT_OBJECT_0)
			{
				if (!GetOverlappedResult(m_hComm, &m_overlappedWrite, &uWriteLength, false))
				{
					return(0);
				}
				else
				{
					return uWriteLength;
				}
			}

			uWriteLength = 0;
		}
	}

	return uWriteLength;
}

unsigned long SerialPort::ReadChar(unsigned long dwBufferLength, char *buff, unsigned long dwWaitTime)
{


	DWORD		dwError;
	COMSTAT		Stat;
	if (::ClearCommError(m_hComm, &dwError, &Stat) && dwError > 0)	//清除错误
	{
		::PurgeComm(m_hComm, PURGE_RXABORT | PURGE_RXCLEAR); /*清除输入缓冲区*/
		return 0;
	}

	if (!Stat.cbInQue)// 缓冲区无数据
	{
		return 0;
	}

	unsigned long uReadLength = 0;
	//dwBufferLength = dwBufferLength - 1 > Stat.cbInQue ? Stat.cbInQue : dwBufferLength - 1;
	if (!::ReadFile(m_hComm, buff, dwBufferLength, &uReadLength, &m_overlappedRead)) //2000 下 ReadFile 始终返回 True
	{
		if (::GetLastError() == ERROR_IO_PENDING) // 结束异步I/O
		{
			WaitForSingleObject(m_overlappedRead.hEvent, dwWaitTime);	//等待20ms
			if (!::GetOverlappedResult(m_hComm, &m_overlappedRead, &uReadLength, false))
			{
				if (::GetLastError() != ERROR_IO_INCOMPLETE)//其他错误
				{
					uReadLength = 0;
				}
			}
		}
		else
		{
			uReadLength = 0;
		}
	}
	return uReadLength;
}

char SerialPort::MODBUS_ReadMultiOptocoupler(unsigned char rtu, unsigned short int RegAdd, unsigned short int RegCount, bool *list)
{
	unsigned short int crc16;
	unsigned short int crctmp;

	unsigned char buff[256];

	memset(buff, 0x00, 255);

	buff[0] = rtu;
	buff[1] = 0x02;
	buff[2] = (unsigned char)((RegAdd) >> 8);
	buff[3] = (unsigned char)(RegAdd);
	buff[4] = (unsigned char)(RegCount >> 8);
	buff[5] = (unsigned char)RegCount;
	crc16 = CalcCrcFast(buff, 6);
	buff[6] = (unsigned char)(crc16 >> 8);
	buff[7] = (unsigned char)crc16;

	TRACE("W READ :%X-%X-%X-%X-%X-%X-%X-%X\n"
		, buff[0], buff[1], buff[2], buff[3], buff[4], buff[5], buff[6], buff[7], buff[8]);
	unsigned long strlen;
	strlen = WriteChar(8, (char *)buff);

	if (strlen == 8)
	{
		//读数据
		memset(buff, 0x00, 255);
		Sleep(50);
		strlen = ReadChar(255, (char *)buff, 1000);
		if (strlen == 0)
		{
			//无返回
			return(-2);
		}
		else
		{
			//返回长度有效,解析接收缓冲区
			if (strlen == (3 + ((RegCount + 7) / 8) + 2) && buff[0] == rtu && buff[1] == 0x02)
			{
				crc16 = CalcCrcFast(buff, 3 + ((RegCount + 7) / 8));
				crctmp = buff[strlen - 2];
				crctmp = crctmp << 8 | buff[strlen - 1];
				if (crc16 == crctmp)
				{
					unsigned char row = 0, col = 0;
					for (int i = 0; i<RegCount; i++)
					{
						row = i / 8;
						col = i % 8;
						list[i] = buff[3 + row] >> col & 0x01;
					}
				}
				else
				{
					return(-1);
				}
			}
			else
			{
				return(-1);
			}
		}
	}
	else
	{
		return(-2);
	}

	TRACE("W WRITE :%X-%X-%X-%X-%X-%X\n"
		, buff[0], buff[1], buff[2], buff[3], buff[4], buff[5]);
	return(1);
}

bool SerialPort::Write_Register(char data[], int dataLength)
{
	DWORD dwWrittenLen = 0;
	if (!WriteFile(m_hComm, data, dataLength, &dwWrittenLen, NULL))
	{
		return false;
	}
	return true;
}